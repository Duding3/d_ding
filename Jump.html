<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ìŠ¬ë¼ì„ ì í”„ - JiHye Mini-Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        .game-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        h1 {
            color: #4ade80;
            font-size: 1.8rem;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
        }

        .refresh-btn {
            background: #4ade80;
            border: none;
            color: #1a1a2e;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
        }

        #gameCanvas {
            border: 3px solid #4ade80;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(74, 222, 128, 0.3);
        }

        .controls-info {
            margin-top: 15px;
            color: #888;
            font-size: 0.85rem;
            text-align: center;
        }

        .charge-bar-container {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
            border: 2px solid #4ade80;
        }

        .charge-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4ade80, #22c55e, #16a34a);
            transition: width 0.05s;
            border-radius: 8px;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .start-btn {
            background: #4ade80;
            color: #1a1a2e;
            border: none;
            padding: 20px 50px;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 15px;
            cursor: pointer;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .game-over-screen h2 {
            color: #ef4444;
            font-size: 3rem;
            margin-bottom: 20px;
        }

        .game-over-screen p {
            color: #fff;
            font-size: 1.5rem;
            margin-bottom: 30px;
        }
    </style>
</head>

<body>
    <div class="game-header">
        <h1>ğŸŸ¢ ìŠ¬ë¼ì„ ì í”„</h1>
        <button class="refresh-btn" onclick="location.reload(true)">ìƒˆë¡œê³ ì¹¨</button>
    </div>

    <canvas id="gameCanvas" width="400" height="600"></canvas>

    <div class="charge-bar-container">
        <div class="charge-bar" id="chargeBar"></div>
    </div>

    <div class="controls-info">
        SPACE ì§§ê²Œ = ì‘ì€ ì í”„ | SPACE ê¸¸ê²Œ ì°¨ì§• = ë†’ì€ ì í”„
    </div>

    <div class="slider-area">
        <span class="slider-label">íˆ¬ëª…ë„</span>
        <input type="range" id="opacitySlider" min="30" max="100" value="100">
    </div>

    <style>
        .slider-area {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px 20px;
            background: rgba(74, 222, 128, 0.1);
            border: 2px solid #4ade80;
            border-radius: 10px;
            width: 300px;
        }

        .slider-label {
            color: #4ade80;
            font-weight: bold;
            font-size: 0.9rem;
        }

        #opacitySlider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: rgba(74, 222, 128, 0.2);
            border-radius: 4px;
            cursor: pointer;
        }

        #opacitySlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4ade80;
            cursor: pointer;
        }
    </style>

    <div id="startScreen">
        <h1 style="font-size: 2.5rem; margin-bottom: 30px;">ğŸŸ¢ ìŠ¬ë¼ì„ ì í”„</h1>
        <p style="color: #aaa; margin-bottom: 20px;">ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ê¸¸ê²Œ ëˆŒëŸ¬ ì°¨ì§•í•˜ê³ <br>ë†’ì´ ì í”„í•˜ì„¸ìš”!</p>
        <button class="start-btn" onclick="startGame()">START</button>
    </div>

    <div class="game-over-screen" id="gameOverScreen">
        <h2>GAME OVER</h2>
        <p>ìµœê³  ë†’ì´: <span id="finalScore">0</span>m</p>
        <button class="start-btn" onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const chargeBar = document.getElementById('chargeBar');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreEl = document.getElementById('finalScore');

        // ê²Œì„ ìƒìˆ˜ (ì†ë„ ëŠë¦¬ê²Œ ì¡°ì •)
        const GRAVITY = 0.35;
        const MAX_CHARGE = 60;
        const MIN_JUMP = -6;
        const MAX_JUMP = -14;
        const PLAYER_SIZE = 30;
        const PLATFORM_HEIGHT = 15;

        // ê²Œì„ ìƒíƒœ
        let gameStarted = false;
        let gameOver = false;
        let player, platforms, camera, score, maxHeight;
        let highScore = 0; // ìµœê³  ìŠ¤ì½”ì–´
        let isCharging = false;
        let chargeTime = 0;

        // ë°°ê²½ êµ¬ì—­ ì •ì˜
        const ZONES = [
            { name: 'mountain', minY: 0, maxY: 2000, colors: ['#2d5016', '#1a3009'] },
            { name: 'ocean', minY: 2000, maxY: 4000, colors: ['#0369a1', '#0c4a6e'] },
            { name: 'sky', minY: 4000, maxY: 6000, colors: ['#38bdf8', '#0ea5e9'] },
            { name: 'space', minY: 6000, maxY: Infinity, colors: ['#1e1b4b', '#0f0a1a'] }
        ];

        function init() {
            // ë°œíŒ ë¨¼ì € ìƒì„±
            platforms = [];
            generateInitialPlatforms();

            // í”Œë ˆì´ì–´ë¥¼ ë°”ë‹¥(ground) ìœ„ì— ë°°ì¹˜
            const groundPlatform = platforms[0]; // index 0ì´ ground
            player = {
                x: canvas.width / 2 - PLAYER_SIZE / 2,
                y: groundPlatform.y - PLAYER_SIZE,
                vx: 0,
                vy: 0,
                width: PLAYER_SIZE,
                height: PLAYER_SIZE,
                onGround: true
            };

            camera = { y: 0 };
            score = 0;
            maxHeight = 0;
            chargeTime = 0;
            isCharging = false;
        }

        function generateInitialPlatforms() {
            // ë°”ë‹¥ ë°œíŒ (í™”ë©´ ì „ì²´ ë„ˆë¹„)
            platforms.push({
                x: 0,
                y: canvas.height - 30,
                width: canvas.width,
                height: 30,
                type: 'ground'
            });

            // ì‹œì‘ ë°œíŒ (ë°”ë‹¥ ë°”ë¡œ ìœ„)
            platforms.push({
                x: canvas.width / 2 - 80,
                y: canvas.height - 80,
                width: 160,
                height: PLATFORM_HEIGHT,
                type: 'static'
            });

            // ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ë°œíŒë“¤
            for (let i = 1; i < 200; i++) {
                addPlatform(i * 80 + 100);
            }
        }

        function addPlatform(worldY) {
            const isMoving = Math.random() < 0.25; // 25% í™•ë¥ ë¡œ ì´ë™ ë°œíŒ
            const width = 60 + Math.random() * 60;
            const x = Math.random() * (canvas.width - width);

            platforms.push({
                x: x,
                y: canvas.height - worldY,
                width: width,
                height: PLATFORM_HEIGHT,
                type: isMoving ? 'moving' : 'static',
                moveSpeed: isMoving ? (0.5 + Math.random() * 1) * (Math.random() < 0.5 ? 1 : -1) : 0,
                originalX: x
            });
        }

        function getZoneForHeight(height) {
            for (let zone of ZONES) {
                if (height >= zone.minY && height < zone.maxY) {
                    return zone;
                }
            }
            return ZONES[ZONES.length - 1];
        }

        function drawBackground() {
            const height = maxHeight;
            const zone = getZoneForHeight(height);

            // ê·¸ë¼ë°ì´ì…˜ ë°°ê²½
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, zone.colors[0]);
            gradient.addColorStop(1, zone.colors[1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // êµ¬ì—­ë³„ ì¥ì‹
            if (zone.name === 'mountain') {
                drawMountainDecorations();
            } else if (zone.name === 'ocean') {
                drawOceanDecorations();
            } else if (zone.name === 'sky') {
                drawSkyDecorations();
            } else if (zone.name === 'space') {
                drawSpaceDecorations();
            }
        }

        function drawMountainDecorations() {
            // êµ¬ë¦„
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(50, 100, 30, 0, Math.PI * 2);
            ctx.arc(80, 100, 40, 0, Math.PI * 2);
            ctx.arc(120, 100, 30, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(320, 200, 25, 0, Math.PI * 2);
            ctx.arc(350, 200, 35, 0, Math.PI * 2);
            ctx.arc(380, 200, 25, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawOceanDecorations() {
            // íŒŒë„ íš¨ê³¼
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 10) {
                    const y = 100 + i * 80 + Math.sin((x + Date.now() * 0.001) * 0.05) * 10;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // ë¬¼ê³ ê¸°
            ctx.fillStyle = 'rgba(255, 200, 100, 0.5)';
            const fishX = (Date.now() * 0.05) % (canvas.width + 50) - 25;
            ctx.beginPath();
            ctx.ellipse(fishX, 300, 15, 8, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawSkyDecorations() {
            // í° êµ¬ë¦„
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            for (let i = 0; i < 5; i++) {
                const x = (i * 100 + Date.now() * 0.01) % (canvas.width + 100) - 50;
                ctx.beginPath();
                ctx.arc(x, 80 + i * 50, 25 + i * 5, 0, Math.PI * 2);
                ctx.arc(x + 30, 80 + i * 50, 30 + i * 5, 0, Math.PI * 2);
                ctx.arc(x + 60, 80 + i * 50, 25 + i * 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // ìƒˆ
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                const x = 100 + i * 100;
                const y = 150 + i * 80;
                ctx.beginPath();
                ctx.moveTo(x - 10, y);
                ctx.quadraticCurveTo(x, y - 10, x + 10, y);
                ctx.stroke();
            }
        }

        function drawSpaceDecorations() {
            // ë³„
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % canvas.width;
                const y = (i * 53) % canvas.height;
                const size = 1 + (i % 3);
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // í–‰ì„±
            const gradient = ctx.createRadialGradient(350, 150, 10, 350, 150, 40);
            gradient.addColorStop(0, '#f472b6');
            gradient.addColorStop(1, '#9333ea');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(350, 150, 35, 0, Math.PI * 2);
            ctx.fill();

            // í† ì„± ê³ ë¦¬
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(350, 150, 55, 15, 0.3, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawPlatforms() {
            platforms.forEach(p => {
                const screenY = p.y + camera.y;

                // í™”ë©´ ë°–ì´ë©´ ê·¸ë¦¬ì§€ ì•ŠìŒ
                if (screenY < -50 || screenY > canvas.height + 50) return;

                // ë†’ì´ì— ë”°ë¥¸ ë°œíŒ ìŠ¤íƒ€ì¼
                const height = -p.y + canvas.height - 50;
                const zone = getZoneForHeight(height);

                let platformColor;
                if (zone.name === 'mountain') {
                    platformColor = p.type === 'moving' ? '#8b5a2b' : '#654321';
                } else if (zone.name === 'ocean') {
                    platformColor = p.type === 'moving' ? '#0891b2' : '#0e7490';
                } else if (zone.name === 'sky') {
                    platformColor = p.type === 'moving' ? '#f0abfc' : '#e879f9';
                } else {
                    platformColor = p.type === 'moving' ? '#a855f7' : '#7c3aed';
                }

                // ë°œíŒ ê·¸ë¦¼ì
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(p.x + 3, screenY + 3, p.width, p.height);

                // ë°œíŒ ë³¸ì²´
                const grad = ctx.createLinearGradient(p.x, screenY, p.x, screenY + p.height);
                grad.addColorStop(0, platformColor);
                grad.addColorStop(1, shadeColor(platformColor, -30));
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.roundRect(p.x, screenY, p.width, p.height, 5);
                ctx.fill();

                // ì´ë™ ë°œíŒ í‘œì‹œ
                if (p.type === 'moving') {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.moveTo(p.x + p.width / 2 - 10, screenY + p.height / 2);
                    ctx.lineTo(p.x + p.width / 2, screenY + p.height / 2 - 4);
                    ctx.lineTo(p.x + p.width / 2 + 10, screenY + p.height / 2);
                    ctx.lineTo(p.x + p.width / 2, screenY + p.height / 2 + 4);
                    ctx.fill();
                }
            });
        }

        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }

        function drawSlime() {
            const screenY = player.y + camera.y;
            const centerX = player.x + player.width / 2;
            const centerY = screenY + player.height / 2;

            // ì°¨ì§• íš¨ê³¼
            let squish = 1;
            if (isCharging && player.onGround) {
                squish = 1 - (chargeTime / MAX_CHARGE) * 0.3;
            }

            // ìŠ¬ë¼ì„ ê·¸ë¦¼ì
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(centerX + 3, screenY + player.height + 3, player.width / 2, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // ìŠ¬ë¼ì„ ëª¸ì²´
            const bodyGrad = ctx.createRadialGradient(
                centerX - 5, centerY - 5, 0,
                centerX, centerY, player.width / 2
            );
            bodyGrad.addColorStop(0, '#86efac');
            bodyGrad.addColorStop(0.7, '#4ade80');
            bodyGrad.addColorStop(1, '#22c55e');

            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(
                centerX,
                screenY + player.height / 2 + (1 - squish) * player.height / 4,
                player.width / 2,
                (player.height / 2) * squish,
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // ìŠ¬ë¼ì„ ìœ¤ê³½
            ctx.strokeStyle = '#16a34a';
            ctx.lineWidth = 2;
            ctx.stroke();

            // ëˆˆ
            const eyeY = screenY + player.height / 2 - 5 + (1 - squish) * player.height / 4;

            // ì™¼ìª½ ëˆˆ
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(centerX - 7, eyeY, 6, 7 * squish, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(centerX - 6, eyeY + 1, 3, 0, Math.PI * 2);
            ctx.fill();

            // ì˜¤ë¥¸ìª½ ëˆˆ
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(centerX + 7, eyeY, 6, 7 * squish, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(centerX + 8, eyeY + 1, 3, 0, Math.PI * 2);
            ctx.fill();

            // ë³¼í„°ì¹˜
            ctx.fillStyle = 'rgba(255, 150, 150, 0.5)';
            ctx.beginPath();
            ctx.ellipse(centerX - 12, eyeY + 8, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(centerX + 12, eyeY + 8, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // ì°¨ì§• ì´í™íŠ¸ (ë°” í˜•íƒœë¡œ ìŠ¬ë¼ì„ ìœ„ì— í‘œì‹œ)
            if (isCharging && player.onGround) {
                const chargePercent = chargeTime / MAX_CHARGE;

                // ì°¨ì§•ë°” ë°°ê²½
                const barWidth = 50;
                const barHeight = 8;
                const barX = centerX - barWidth / 2;
                const barY = screenY - 25;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                ctx.strokeStyle = '#4ade80';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);

                // ì°¨ì§• ì§„í–‰ë°”
                const gradient = ctx.createLinearGradient(barX, barY, barX + barWidth * chargePercent, barY);
                gradient.addColorStop(0, '#4ade80');
                gradient.addColorStop(0.5, '#22c55e');
                gradient.addColorStop(1, '#16a34a');
                ctx.fillStyle = gradient;
                ctx.fillRect(barX + 1, barY + 1, (barWidth - 2) * chargePercent, barHeight - 2);

                // ì›í˜• ì´í™íŠ¸ë„ ìœ ì§€
                ctx.strokeStyle = `rgba(74, 222, 128, ${chargePercent})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, player.width / 2 + 8 + chargePercent * 8, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function drawScore() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(canvas.width - 130, 10, 120, 70);
            ctx.strokeStyle = '#4ade80';
            ctx.lineWidth = 2;
            ctx.strokeRect(canvas.width - 130, 10, 120, 70);

            ctx.textAlign = 'right';

            // í˜„ì¬ ìŠ¤ì½”ì–´
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 11px Segoe UI';
            ctx.fillText('í˜„ì¬ ìŠ¤ì½”ì–´', canvas.width - 20, 28);
            ctx.font = 'bold 16px Segoe UI';
            ctx.fillStyle = '#fff';
            ctx.fillText(Math.floor(maxHeight) + 'm', canvas.width - 20, 45);

            // ìµœê³  ìŠ¤ì½”ì–´
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 11px Segoe UI';
            ctx.fillText('ìµœê³  ìŠ¤ì½”ì–´', canvas.width - 20, 60);
            ctx.font = 'bold 16px Segoe UI';
            ctx.fillStyle = '#4ade80';
            ctx.fillText(Math.floor(highScore) + 'm', canvas.width - 20, 77);
        }

        function updatePlayer() {
            if (!gameStarted || gameOver) return;

            // ì´ë™ ë°œíŒ ë¨¼ì € ì—…ë°ì´íŠ¸
            platforms.forEach(p => {
                if (p.type === 'moving') {
                    p.x += p.moveSpeed;
                    if (p.x < 0 || p.x + p.width > canvas.width) {
                        p.moveSpeed *= -1;
                    }
                }
            });

            // ì¤‘ë ¥ ì ìš©
            if (!player.onGround) {
                player.vy += GRAVITY;
            }

            // ìµœëŒ€ ë‚™í•˜ ì†ë„ ì œí•œ
            if (player.vy > 15) player.vy = 15;

            // ìˆ˜í‰ ì´ë™
            player.x += player.vx;

            // ì¢Œìš° ë²½ ì¶©ëŒ
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

            // ìˆ˜ì§ ì´ë™ ì „ ìœ„ì¹˜ ì €ì¥
            const prevY = player.y;
            player.y += player.vy;

            // ë°œíŒ ì¶©ëŒ ì²´í¬
            player.onGround = false;
            let landedOnPlatform = null;

            platforms.forEach(p => {
                // ì¶©ëŒ ì²´í¬ (ì•„ë˜ë¡œ ë–¨ì–´ì§ˆ ë•Œë§Œ - vy >= 0)
                if (player.vy >= 0) {
                    const playerBottom = player.y + player.height;
                    const prevPlayerBottom = prevY + player.height;
                    const platformTop = p.y;

                    // ìˆ˜í‰ ë²”ìœ„ ì²´í¬
                    const horizontalOverlap = player.x + player.width > p.x + 5 && player.x < p.x + p.width - 5;

                    // ìˆ˜ì§ ì¶©ëŒ ì²´í¬: ì´ì „ í”„ë ˆì„ì—ì„œëŠ” ë°œíŒ ìœ„ì— ìˆì—ˆê³ , í˜„ì¬ëŠ” ë°œíŒì„ í†µê³¼í–ˆê±°ë‚˜ ë°œíŒ ìœ„ì— ìˆìŒ
                    if (horizontalOverlap && prevPlayerBottom <= platformTop + 5 && playerBottom >= platformTop) {
                        player.y = platformTop - player.height;
                        player.vy = 0;
                        player.onGround = true;
                        landedOnPlatform = p;
                    }
                }
            });

            // ì´ë™ ë°œíŒ ìœ„ì— ìˆìœ¼ë©´ ê°™ì´ ì´ë™
            if (landedOnPlatform && landedOnPlatform.type === 'moving') {
                player.x += landedOnPlatform.moveSpeed;
            }

            // ê³µì¤‘ ë§ˆì°°ë ¥ (ì í”„ ì¤‘ ì¢Œìš° ì´ë™ ê°ì†)
            if (!player.onGround && player.vx !== 0) {
                player.vx *= 0.98;
                if (Math.abs(player.vx) < 0.1) player.vx = 0;
            }

            // ë†’ì´ ê³„ì‚°
            const currentHeight = Math.max(0, -(player.y - (canvas.height - 80)));
            if (currentHeight > maxHeight) {
                maxHeight = currentHeight;
                if (maxHeight > highScore) {
                    highScore = maxHeight;
                }
            }

            // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ - í”Œë ˆì´ì–´ê°€ í™”ë©´ ì¤‘ì•™ë³´ë‹¤ ìœ„ë¡œ ì˜¬ë¼ê°€ë©´ ë”°ë¼ê°
            const targetCameraY = Math.max(0, -player.y + canvas.height * 0.6);
            if (targetCameraY > camera.y) {
                camera.y += (targetCameraY - camera.y) * 0.1; // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼
            } else {
                // ë‚´ë ¤ê°ˆ ë•Œë„ ë”°ë¼ê°€ë˜, ë°”ë‹¥ ë°œíŒì´ ë³´ì´ë„ë¡
                camera.y += (targetCameraY - camera.y) * 0.05;
            }
            if (camera.y < 0) camera.y = 0;

            // ê²Œì„ì˜¤ë²„ ì²´í¬ - ì¹´ë©”ë¼ í™”ë©´ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë©´
            const screenY = player.y + camera.y;
            if (screenY > canvas.height + 50) {
                endGame();
            }

            // ìƒˆë¡œìš´ ë°œíŒ ìƒì„±
            const highestPlatformY = Math.min(...platforms.map(p => p.y));
            if (-highestPlatformY + canvas.height < maxHeight + 500) {
                addPlatform(maxHeight + 500);
            }
        }

        function update() {
            if (isCharging && player.onGround) {
                chargeTime = Math.min(chargeTime + 1, MAX_CHARGE);
                chargeBar.style.width = (chargeTime / MAX_CHARGE * 100) + '%';
            }

            updatePlayer();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawPlatforms();
            drawSlime();
            drawScore();
        }

        function gameLoop() {
            if (gameStarted && !gameOver) {
                update();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        function jump() {
            if (!player.onGround || gameOver) return;

            const chargePercent = chargeTime / MAX_CHARGE;
            player.vy = MIN_JUMP + (MAX_JUMP - MIN_JUMP) * chargePercent;
            player.onGround = false;
            chargeTime = 0;
            chargeBar.style.width = '0%';
        }

        function startGame() {
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            gameStarted = true;
            gameOver = false;
            init();
        }

        function restartGame() {
            gameOverScreen.style.display = 'none';
            gameOver = false;
            init();
        }

        function endGame() {
            gameOver = true;
            finalScoreEl.textContent = Math.floor(maxHeight);
            gameOverScreen.style.display = 'flex';
        }

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !e.repeat) {
                e.preventDefault();
                if (!gameStarted) {
                    startGame();
                } else if (gameOver) {
                    restartGame();
                } else {
                    isCharging = true;
                }
            }
            if (e.code === 'ArrowLeft') player.vx = -4;
            if (e.code === 'ArrowRight') player.vx = 4;
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                if (isCharging) {
                    jump();
                    isCharging = false;
                }
            }
            if (e.code === 'ArrowLeft' && player.vx < 0) player.vx = 0;
            if (e.code === 'ArrowRight' && player.vx > 0) player.vx = 0;
        });

        // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼)
        let touchStartTime = 0;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameStarted) {
                startGame();
            } else if (gameOver) {
                restartGame();
            } else {
                isCharging = true;
                touchStartTime = Date.now();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (isCharging) {
                jump();
                isCharging = false;
            }
        });

        // íˆ¬ëª…ë„ ìŠ¬ë¼ì´ë”
        document.getElementById('opacitySlider').addEventListener('input', (e) => {
            canvas.style.opacity = e.target.value / 100;
        });

        // ì´ˆê¸°í™” ë° ê²Œì„ ë£¨í”„ ì‹œì‘
        init();
        gameLoop();
    </script>
</body>

</html>